#  Cppcheck и Clang-Tidy: Инструменты статического анализа кода для C++

## Введение

В мире кода, где бессонные ночи, кружки кофе и жесткие дедлайны стали обыденностью, релиз проекта становится моментом истинного испытания. 
Взглянем на [катастрофу AT&T(1990)](https://youtu.be/HD5ukgbBXAM). Одна банальная ошибка в цикле привела к серьезным потерям, поэтому миром была разработана одна весьма полезная инновация - статический анализ кода.


В этой статье мы проведем сравнительный анализ двух инструментов для C++: Cppcheck и Clang-Tidy 

![versus](https://github.com/avolidaga/ITMO/blob/main/3-course/Computer%20Architecture/paper/versus.png)


Но какой из них лучше подходит для ваших проектов? Какой из них предоставляет более точные результаты? Как они взаимодействуют с современными стандартами C++? 
Эти вопросы станут фокусом нашего сегодняшнего сравнения.


## Немного теории

> Cppcheck - это инструмент статического анализа кода, разработанный для обнаружения потенциальных ошибок и неоптимальностей в исходном коде на C и C++. 

> Clang-Tidy - это часть проекта LLVM и инструмент статического анализа кода, предназначенный для улучшения качества кода, совместимого с компилятором Clang.

 
## История развития

Cppcheck начал свое развитие в 2007 году. За годы активной разработки он стал широко используемым инструментом в сообществе разработчиков на C++. В течение своей истории Cppcheck постоянно обновлялся, добавляя новые проверки и улучшая свою эффективность, чтобы соответствовать современным требованиям разработки на C++.

Clang-Tidy развивается в рамках проекта LLVM и начал активно использоваться с момента появления. Его история связана с непрерывным улучшением и обновлением. С каждым новым релизом LLVM Clang-Tidy пополняется дополнительными функциями и проверками, обеспечивая современные возможности для статического анализа кода на C++.

## 1. Обзор инструментов

### 1.1 Cppcheck






Преимущества:

- Легкость в использовании и настройке.
- Поддержка широкого спектра проверок на ошибки.
- Бесплатный и с открытым исходным кодом.

Недостатки:


- Ограниченная поддержка новых стандартов языка C++. 
- Не всегда точное выявление сложных ошибок.
- Меньший набор опций настройки.

 Установка на примере Ubuntu: `sudo apt-get install cppcheck`


### 1.2 Clang-Tidy


Преимущества:

- Интеграция с компилятором Clang, что позволяет использовать современные стандарты языка C++.
- Расширенные возможности по настройке и созданию пользовательских правил.
- Активная поддержка и обновления.

Недостатки:

- Более сложная настройка по сравнению с cppcheck.
- Зависимость от версии компилятора Clang.

 Установка на примере Ubuntu: `sudo apt-get install clang-tools`


## 2. Алгоритмическая сложность
### 2.1 Cppcheck
Cppcheck обладает небольшой алгоритмической сложностью благодаря использованию своего собственного лексического и синтаксического анализатора. Однако, сложность может возрасти при внесении большого объема пользовательских модулей проверки.

### 2.2 Clang-Tidy
Clang-tidy, в свою очередь, может иметь более высокую алгоритмическую сложность из-за интеграции с Clang Frontend и Clang Static Analyzer. Это позволяет ему проводить более глубокий анализ кода, что может повлечь за собой дополнительные вычислительные затраты.


## 3. AST

### 3.1 Cppcheck AST

AST в cppcheck представляет собой абстрактную синтаксическую структуру анализируемого кода.

AST Cppcheck предназначен для захвата различных элементов кода, что позволяет инструменту выполнять статический анализ и обнаруживать потенциальные ошибки или уязвимости. Он разбирает исходный код и строит внутреннее представление структуры кода, которое затем анализируется на предмет потенциальных проблем.


### 3.2 Clang AST

Практически каждый компилятор и статический анализатор использует AST для представления исходного кода. AST, используемое в Clang, очень детализированное и сложное, но вы получите удовольствие, изучая различные классы элементов Clang AST. Ниже приводится краткое [введение](http://clang.llvm.org/docs/IntroductionToTheClangAST.html) в Clang AST, но самый простой путь изучить его, это просто делать дампы AST для простых исходников, и смотреть, какое AST им соответствует.

В общем, Clang AST сделано из двух очень гибких классов: Decl и Stmt. У обоих есть множество подклассов, вот несколько примеров:

- [FunctionDecl](http://clang.llvm.org/doxygen/classclang_1_1FunctionDecl.html) — прототип или объявление функции

- [BinaryOperator](https://clang.llvm.org/doxygen/classclang_1_1BinaryOperator.html) — бинарный оператор, например (a + b)

- [CallExpr](http://clang.llvm.org/doxygen/classclang_1_1CallExpr.html) — вызов функции, например, foo(x);

Большинство классов имеют «говорящие» имена, например, ForStmt, IfStmt, и ReturnStmt. Вы поймёте суть AST, поиграв с ним несколько минут. Вы можете найти документацию по классам AST, поискав что-либо вроде “Clang FunctionDecl.”

Ниже приведен пример абстрактного синтаксического дерева
![ast](https://github.com/avolidaga/ITMO/blob/main/3-course/Computer%20Architecture/paper/ast.png)


## 4. Пример использования
```cpp

#include <iostream>
#include <cstring>

class Resource {
public:
    Resource() {
        data = new char[10];
        std::strcpy(data, "Hello");
    }

    ~Resource() {
        delete[] data;
    }

    void useResource() {
        std::cout << data << std::endl;
    }

private:
    char* data;
};

int main() {
    Resource* resource = new Resource();

    // Ошибка: Утечка памяти, не вызван delete
    // Проблема с использованием delete в деструкторе
    return 0;
}
```

Сначала применим cppcheck к коду с помощью следующей команды в терминале:

```
cppcheck example.cpp
```

Cppcheck выдаст предупреждение о потенциальной утечке памяти:

```
[example.cpp:25]: (error) Memory leak: resource
```

Cppcheck выявляет, что ресурс создан в main и не освобожден перед завершением программы, что приводит к утечке памяти.

Теперь применим clang-tidy к коду с использованием следующей команды:

```
clang-tidy example.cpp
````
Clang-tidy также обнаружит проблему и выдаст предупреждение:

```
example.cpp:25:5: warning: Potential leak of memory pointed to by 'resource' [clang-analyzer-cplusplus.NewDeleteLeaks]
    return 0;
    ^
example.cpp:19:19: note: Memory is allocated
    Resource* resource = new Resource();
                  ^
example.cpp:25:5: note: Memory leak
    return 0;
    ^
```
Clang-tidy также указывает на потенциальную утечку памяти и предостерегает разработчика об этой проблеме.


## 5. Интеграция с Системами Непрерывной Интеграции (CI/CD)
Интеграция статического анализа кода с системами непрерывной интеграции (CI) и непрерывной доставки (CD) является важным этапом в разработке программного обеспечения. Оба инструмента, Cppcheck и Clang-Tidy, предоставляют возможности для автоматизированной интеграции с CI/CD системами, что способствует улучшению процесса разработки и поддерживает высокий уровень качества кода.

### 7.1 Интеграция Cppcheck с CI/CD
Cppcheck может быть легко интегрирован с различными системами CI/CD для автоматического анализа кода на каждом этапе сборки. Это позволяет выявлять потенциальные проблемы на ранних этапах разработки и предотвращать попадание некорректного кода в основную ветку проекта.

Пример использования в конфигурации CI/CD:

```
name: Cppcheck Analysis

on:
  push:
    branches:
      - main

jobs:
  cppcheck:
    runs-on: ubuntu-latest
    steps:
      - name: Checkout Repository
        uses: actions/checkout@v2

      - name: Setup Cppcheck
        run: sudo apt-get install cppcheck

      - name: Run Cppcheck Analysis
        run: cppcheck --enable=all --error-exitcode=1 .
```

В данном примере, при каждом коммите в ветку main происходит автоматический запуск анализа кода с использованием Cppcheck. Если обнаружатся ошибки, процесс CI завершится с ошибкой, предотвращая принятие некорректного кода.


### 7.2 Интеграция Clang-Tidy с CI/CD
Clang-Tidy также обеспечивает возможности интеграции с CI/CD системами, позволяя автоматически выполнять статический анализ кода на этапе сборки проекта. Это поддерживает непрерывное обеспечение высокого стандарта кодирования и предотвращает возможные проблемы на ранних этапах разработки.


Пример использования в конфигурации CI/CD:
```
stages:
  - build

variables:
  CC: "clang"
  CXX: "clang++"

build:
  stage: build
  script:
    - apt-get update -qy
    - apt-get install -y clang-tidy
    - mkdir build
    - cd build
    - cmake ..
    - make
    - clang-tidy -p . --checks=* source.cpp
```

В этом примере, на этапе сборки проекта с использованием GitLab CI, производится установка Clang-Tidy, компиляция исходного кода, и запуск статического анализа с помощью Clang-Tidy. В случае обнаружения проблем, процесс CI завершится с ошибкой.

Интеграция статического анализа с CI/CD системами помогает автоматизировать процесс обнаружения и исправления ошибок на ранних этапах разработки, способствуя поддержанию высокого качества кода и сокращению времени между обнаружением и устранением проблем.

## 6. Прочее

1. Поддержка стандартов C++: 
Cppcheck обеспечивает базовую поддержку современных стандартов C++, но иногда может отставать в поддержке последних языковых возможностей. Clang-Tidy, будучи частью проекта LLVM, обычно обеспечивает более актуальную поддержку новых стандартов C++ (C++11, C++14, C++17 и C++20) и языковых возможностей.

2. Интеграция с средами разработки:
Оба инструмента, Cppcheck и Clang-Tidy, легко интегрируются с популярными средами разработки, такими как Visual Studio, CLion и Eclipse. Предоставляются плагины или инструкции по интеграции, что упрощает использование этих инструментов в повседневной разработке.

3. Поддержка платформ:
Cppcheck и Clang-Tidy могут использоваться на различных платформах, включая Windows, Linux и macOS. Однако следует учитывать, что некоторые ограничения могут существовать в зависимости от конкретной платформы.

## Советы

- Планирование и проектирование:
Начинайте с тщательного планирования и проектирования кода. Чем более ясными и структурированными будут ваши планы, тем легче будет избежать ошибок на более поздних этапах разработки.

- Использование констант и перечислений:
Заменяйте магические числа константами и используйте перечисления для ясного и понятного кода. Это уменьшает вероятность опечаток и ошибок.

- Тестирование на ранних этапах: Начинайте тестирование как можно раньше в процессе разработки. Это поможет выявить проблемы на ранних этапах и снизит затраты на их исправление.

- Разделение на функции и модули:
Разбивайте код на логические функции и модули. Это не только облегчит понимание кода, но и уменьшит вероятность ошибок при изменении или добавлении нового функционала.

- Избегание дублирования кода: Избегайте повторения кода. Дублирование увеличивает вероятность ошибок при изменении, так что используйте функции, классы и макросы для избегания избыточного кода.

- Использование адекватных имен переменных:Давайте переменным и функциям ясные имена, отражающие их предназначение. Это сделает код более читаемым и уменьшит возможность недопонимания.

- Ну и конечно использование инструментов статического анализа:
Внедрите инструменты статического анализа кода, такие как cppcheck и clang-tidy, в процесс разработки для автоматического обнаружения потенциальных проблем.

## Заключение

Оба инструмента, cppcheck и clang-tidy, предоставляют ценные возможности для статического анализа кода на языках C и C++. 
Выбор между ними зависит от требований проекта, уровня гибкости и детализации анализа, а также от зависимости от конкретных стандартов языка программирования. 

Конечно, использование обоих инструментов в сочетании может обеспечить более полное покрытие и высокое качество анализа кода. Поэтому только вам решать каким инструментом воспользоваться.



