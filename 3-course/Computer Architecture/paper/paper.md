#  Cppcheck и Clang-Tidy: Инструменты статического анализа кода для C++

## Введение

В мире кода, где бессонные ночи, кружки кофе и жесткие дедлайны стали обыденностью, релиз проекта становится моментом истинного испытания. 
Взглянем на [катастрофу AT&T(1990)](https://youtu.be/HD5ukgbBXAM). Одна банальная ошибка в цикле привела к серьезным потерям, поэтому миром была разработана одна весьма полезная инновация - статический анализ кода.


В этой статье мы проведем сравнительный анализ двух инструментов для C++: Cppcheck и Clang-Tidy 

![versus](https://github.com/avolidaga/ITMO/blob/main/3-course/Computer%20Architecture/paper/versus.png)


Но какой из них лучше подходит для ваших проектов? Какой из них предоставляет более точные результаты? Как они взаимодействуют с современными стандартами C++? 
Эти вопросы станут фокусом нашего сегодняшнего сравнения.


## Немного теории

> Cppcheck - это инструмент статического анализа кода, разработанный для обнаружения потенциальных ошибок и неоптимальностей в исходном коде на C и C++. 

> Clang-Tidy - это часть проекта LLVM и инструмент статического анализа кода, предназначенный для улучшения качества кода, совместимого с компилятором Clang.

 
## История развития

Cppcheck начал свое развитие в 2007 году. За годы активной разработки он стал широко используемым инструментом в сообществе разработчиков на C++. В течение своей истории Cppcheck постоянно обновлялся, добавляя новые проверки и улучшая свою эффективность, чтобы соответствовать современным требованиям разработки на C++.

Clang-Tidy развивается в рамках проекта LLVM и начал активно использоваться с момента появления. Его история связана с непрерывным улучшением и обновлением. С каждым новым релизом LLVM Clang-Tidy пополняется дополнительными функциями и проверками, обеспечивая современные возможности для статического анализа кода на C++.

## 1. Обзор инструментов

### 1.1 Cppcheck






Преимущества:

- Легкость в использовании и настройке.
- Поддержка широкого спектра проверок на ошибки.
- Бесплатный и с открытым исходным кодом.

Недостатки:


- Ограниченная поддержка новых стандартов языка C++. 
- Не всегда точное выявление сложных ошибок.
- Меньший набор опций настройки.

 Установка на примере Ubuntu: `sudo apt-get install cppcheck`


### 1.2 Clang-Tidy


Преимущества:

- Интеграция с компилятором Clang, что позволяет использовать современные стандарты языка C++.
- Расширенные возможности по настройке и созданию пользовательских правил.
- Активная поддержка и обновления.

Недостатки:

- Более сложная настройка по сравнению с cppcheck.
- Зависимость от версии компилятора Clang.

 Установка на примере Ubuntu: `sudo apt-get install clang-tools`


## 2. Алгоритмическая сложность
### 2.1 Cppcheck
Cppcheck обладает небольшой алгоритмической сложностью благодаря использованию своего собственного лексического и синтаксического анализатора. Однако, сложность может возрасти при внесении большого объема пользовательских модулей проверки.

### 2.2 Clang-Tidy
Clang-tidy, в свою очередь, может иметь более высокую алгоритмическую сложность из-за интеграции с Clang Frontend и Clang Static Analyzer. Это позволяет ему проводить более глубокий анализ кода, что может повлечь за собой дополнительные вычислительные затраты.


## 3. AST

### 3.1 Cppcheck AST

AST в cppcheck представляет собой абстрактную синтаксическую структуру анализируемого кода.

AST Cppcheck предназначен для захвата различных элементов кода, что позволяет инструменту выполнять статический анализ и обнаруживать потенциальные ошибки или уязвимости. Он разбирает исходный код и строит внутреннее представление структуры кода, которое затем анализируется на предмет потенциальных проблем.


### 3.2 Clang AST

Практически каждый компилятор и статический анализатор использует AST для представления исходного кода. AST, используемое в Clang, очень детализированное и сложное, но вы получите удовольствие, изучая различные классы элементов Clang AST. Ниже приводится краткое [введение](http://clang.llvm.org/docs/IntroductionToTheClangAST.html) в Clang AST, но самый простой путь изучить его, это просто делать дампы AST для простых исходников, и смотреть, какое AST им соответствует.

В общем, Clang AST сделано из двух очень гибких классов: Decl и Stmt. У обоих есть множество подклассов, вот несколько примеров:

- [FunctionDecl](http://clang.llvm.org/doxygen/classclang_1_1FunctionDecl.html) — прототип или объявление функции

- [BinaryOperator](https://clang.llvm.org/doxygen/classclang_1_1BinaryOperator.html) — бинарный оператор, например (a + b)

- [CallExpr](http://clang.llvm.org/doxygen/classclang_1_1CallExpr.html) — вызов функции, например, foo(x);

Большинство классов имеют «говорящие» имена, например, ForStmt, IfStmt, и ReturnStmt. Вы поймёте суть AST, поиграв с ним несколько минут. Вы можете найти документацию по классам AST, поискав что-либо вроде “Clang FunctionDecl.”

## 4. орпм

## 5. Пример использования
```cpp

#include <iostream>
#include <cstring>

class Resource {
public:
    Resource() {
        data = new char[10];
        std::strcpy(data, "Hello");
    }

    ~Resource() {
        delete[] data;
    }

    void useResource() {
        std::cout << data << std::endl;
    }

private:
    char* data;
};

int main() {
    Resource* resource = new Resource();

    // Ошибка: Утечка памяти, не вызван delete
    // Проблема с использованием delete в деструкторе
    return 0;
}
```

Сначала применим cppcheck к коду с помощью следующей команды в терминале:

```bash
cppcheck example.cpp
```

Cppcheck выдаст предупреждение о потенциальной утечке памяти:

```
[example.cpp:25]: (error) Memory leak: resource
```

Cppcheck выявляет, что ресурс создан в main и не освобожден перед завершением программы, что приводит к утечке памяти.

Теперь применим clang-tidy к коду с использованием следующей команды:

```bash
Copy code
clang-tidy example.cpp
````
Clang-tidy также обнаружит проблему и выдаст предупреждение:

```kotlin
Copy code
example.cpp:25:5: warning: Potential leak of memory pointed to by 'resource' [clang-analyzer-cplusplus.NewDeleteLeaks]
    return 0;
    ^
example.cpp:19:19: note: Memory is allocated
    Resource* resource = new Resource();
                  ^
example.cpp:25:5: note: Memory leak
    return 0;
    ^
```
Clang-tidy также указывает на потенциальную утечку памяти и предостерегает разработчика об этой проблеме.


## Заключение

Оба инструмента, cppcheck и clang-tidy, предоставляют ценные возможности для статического анализа кода на языках C и C++. Выбор между ними зависит от требований проекта, уровня гибкости и детализации анализа, а также от зависимости от конкретных стандартов языка программирования. Использование обоих инструментов в сочетании может обеспечить более полное покрытие и высокое качество анализа кода.


